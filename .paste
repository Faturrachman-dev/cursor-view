Okay, I've processed your clarifications. It's clear now that the primary issue with the `visual-maps` not being "used" is a fundamental setup problem with the custom mode prompts themselves. This is a critical insight, and addressing it will significantly improve the system's intended behavior.

Let's break down your questions and my responses, including the necessary file modifications.

---

### 1. Difference between REFLECT and ARCHIVE phases

The `REFLECT` and `ARCHIVE` phases serve distinct but complementary purposes in the Memory Bank system:

*   **REFLECT Phase (Purpose: Learning & Introspection)**
    *   **When it occurs:** Immediately after the `IMPLEMENT` phase is completed for a task.
    *   **Core Activity:** This phase is about looking back at the completed work to extract knowledge and insights. It's an introspection process where the AI (and implicitly, the user) evaluates *how* the task went.
    *   **Key Questions Addressed:** What went well? What challenges were faced and how were they overcome? What key lessons were learned (technical, process, estimation)? Were there unexpected outcomes? What improvements can be made for future tasks?
    *   **Output:** A structured `reflection-[task_name_or_id]-[date].md` document, typically stored in `memory-bank/reflection/`. This document is a record of the *learning journey* and *insights* from the task.
    *   **Goal:** To facilitate continuous improvement of both the development process and the AI's performance.

*   **ARCHIVE Phase (Purpose: Preservation & Formal Closure)**
    *   **When it occurs:** After the `REFLECT` phase is completed and upon explicit user command (`ARCHIVE NOW`).
    *   **Core Activity:** This phase is about formalizing the completion of a task and ensuring all relevant documentation is consolidated and permanently stored for future reference. It's about closing the task's lifecycle.
    *   **Key Actions:** Consolidating summaries from the `PLAN`, `CREATIVE` (if applicable), `IMPLEMENT`, and `REFLECT` phases. Creating a comprehensive `archive-[task_name_or_id]-[date].md` document. Marking the task as fully `COMPLETED` in `tasks.md`. Updating `progress.md` and resetting `activeContext.md` for the next task.
    *   **Output:** A comprehensive `archive-[task_name_or_id]-[date].md` document, typically stored in `memory-bank/archive/`. This document is a consolidated *historical record* of the entire task's lifecycle.
    *   **Goal:** To ensure long-term knowledge preservation, traceability of decisions, and a clear record of completed work for future audits, onboarding, or similar projects.

**Analogy:**
Think of it like this:
*   **REFLECT** is like a **post-game analysis** in sports: "What did we do well? What mistakes did we make? How can we play better next time?"
*   **ARCHIVE** is like **filing the game report and highlights reel** into the team's historical records: "This is the official record of that game, including all the key stats and a summary of what happened."

---

### 2. The "visual-maps" folder trigger problem

You are absolutely correct. The problem is not with the "trigger" mechanism (`fetch_rules`) itself, but with **how the custom mode prompts are currently configured**.

**The Root Cause:**
The `custom_modes_refined/*.md` files (e.g., `custom_modes_refined/creative.md`) contain the *entire detailed instructions* for each mode, including all the steps, sub-steps, and templates. When a user pastes this entire content into Cursor's "Advanced options" for a custom mode, the AI already has all these instructions directly in its primary system prompt.

Because the AI already has the instructions, its internal logic often determines that it doesn't *need* to `fetch_rules` the orchestrator map (e.g., `visual-maps/creative-mode-map.mdc`) because it already has the information. This bypasses the intended hierarchical loading and makes the `visual-maps` orchestrators seemingly unused.

**The Solution:**
The custom mode prompts in `custom_modes_refined/*.md` need to be **drastically simplified**. Their sole purpose should be to:
1.  Acknowledge the mode activation.
2.  State the mode's high-level purpose.
3.  **Explicitly instruct the AI to `fetch_rules` the primary orchestrator map (`visual-maps/*.mdc`) for that mode.**

This will force the AI to load the orchestrator map, which then, in turn, will `fetch_rules` other sub-rules as designed. This is the intended "hierarchical rule loading" mechanism working correctly.

**Required Changes to `custom_modes_refined/*.md` files:**

I will provide the *entire new content* for each of these files. You will need to **replace the existing content** in your `custom_modes_refined/` directory with these simplified versions.

**File: `cursor-memory-bank/custom_modes_refined/creative.md`**

```markdown
# CREATIVE MODE

Your Role: Orchestrate detailed design and architecture work for components flagged in `tasks.md`.

1.  **Acknowledge:** Respond with "OK CREATIVE".
2.  **Orchestrate:** `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/creative-mode-map.mdc`.
```

**File: `cursor-memory-bank/custom_modes_refined/implement.md`**

```markdown
# IMPLEMENT MODE

Your Role: Orchestrate building the planned changes, guided by the implementation plan and creative phase decisions.

1.  **Acknowledge:** Respond with "OK IMPLEMENT".
2.  **Orchestrate:** `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/implement-mode-map.mdc`.
```

**File: `cursor-memory-bank/custom_modes_refined/plan.md`**

```markdown
# PLAN MODE

Your Role: Orchestrate creating a detailed implementation plan based on the task and complexity level.

1.  **Acknowledge:** Respond with "OK PLAN".
2.  **Orchestrate:** `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/plan-mode-map.mdc`.
```

**File: `cursor-memory-bank/custom_modes_refined/reflect_archive.md`**

```markdown
# REFLECT+ARCHIVE MODE

Your Role: Orchestrate the reflection process on the completed task, and upon command, orchestrate archiving.

1.  **Acknowledge:** Respond with "OK REFLECT+ARCHIVE".
2.  **Orchestrate Reflection:** `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/reflect-mode-map.mdc`.
```

**File: `cursor-memory-bank/custom_modes_refined/van.md`**

```markdown
# VAN MODE (Visualize, Analyze, Navigate)

Your Role: Orchestrate the initialization of the project context within the Memory Bank.

1.  **Acknowledge:** Respond with "OK VAN".
2.  **Orchestrate:** `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-mode-map.mdc`.
```

**Important Note for User:** After updating these files, you will need to **manually copy and paste this new, concise content** into the "Advanced options" text box for each corresponding custom mode in your Cursor IDE settings. This is crucial for the system to function as intended.

---

### 3. Enhancing the complexity approach for VAN's quick fix looping

You're right, even with the quick fix feature, looping can occur if the initial assessment isn't robust enough, or if the L1 workflow isn't strict about its boundaries.

**Proposed Enhancements:**

1.  **Stricter L0/L1 Quick Triage Criteria:** Make the criteria for a quick fix even more precise, explicitly ruling out anything that might lead to iteration or unexpected complexity.
2.  **Immediate Re-assessment on L1 Workflow Deviation:** If, during the L0/L1 workflow, the AI encounters a situation that clearly violates the "simple, low-risk" criteria (e.g., requires modifying multiple files, unexpected dependencies, or a design decision), it should immediately stop, flag the issue, and force a re-assessment to a higher complexity level.

**Required Changes to `cursor-memory-bank/.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-mode-map.mdc`:**

I will provide the *entire new content* for this file.

```markdown
---
description: Main orchestrator for VAN mode: platform detection, file verification, complexity determination, and optional QA. Fetched when VAN mode starts.
globs: **/visual-maps/van_mode_split/van-mode-map.mdc
alwaysApply: false
---
# VAN MODE: INITIALIZATION PROCESS MAP (AI Instructions)

> **TL;DR:** Initialize project: **Perform quick triage for immediate L0/L1 fixes.** If not applicable, proceed with platform detection, file verification, complexity determination. For L2+ tasks, transition to PLAN. For formal L1, complete initialization. If 'VAN QA' is called, perform technical validation.

## ðŸ§­ VAN MODE PROCESS FLOW (AI Actions)

1.  **Acknowledge & Determine Entry Point:**
    *   If user typed "VAN": Respond "OK VAN - Beginning Initialization Process." Proceed with step 2.
    *   If user typed "VAN QA": Respond "OK VAN QA - Beginning Technical Validation." Skip to **Step 7 (VAN QA)**.

2.  **Initial Problem Intake & Quick Triage:**
    a.  State: "Performing initial problem intake and quick triage."
    b.  `read_file` the user's prompt and any immediately provided context files (like `error-delete-chat.txt`).
    c.  `read_file` the 1-2 most directly implicated source files if obvious from the error/request (e.g., `server.py` if an API error is mentioned).
    d.  **Decision Point - Quick Fix Assessment (STRICT CRITERIA):**
        *   Based on this *very limited initial review*, can you confidently identify:
            1.  A **single, isolated file modification** (e.g., one function, one variable, one line change)?
            2.  A **clear, unambiguous root cause** (e.g., typo, incorrect variable name, missing import)?
            3.  A **simple, low-risk fix** that is immediately apparent and requires **no design decisions** or **new dependencies**?
            4.  The fix is expected to take **less than 30 minutes** of direct coding?
        *   **If YES to ALL above (High Confidence, Simple, Fast Fix):**
            i.  State: "Initial analysis suggests a straightforward Level 0/1 fix for [brief problem description]. Proceeding with optimized quick fix workflow."
            ii. `edit_file memory-bank/tasks.md` to create a task: "L0/1 Quick Fix: [Problem Description]".
            iii. `edit_file memory-bank/activeContext.md` to log: "Focus: L0/1 Quick Fix - [Problem]. Initial diagnosis: [Root Cause]. Proposed fix: [Brief Fix]."
            iv. `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Level1/optimized-workflow-level1.mdc`.
                *   (This rule guides: implement fix, verify, document concisely in `tasks.md`/`activeContext.md`, then state completion and readiness for a new task).
            v.  **After `Level1/optimized-workflow-level1.mdc` completes, the VAN mode for THIS SPECIFIC QUICK TASK is considered complete.** State this and await further user instruction (e.g., new VAN for another task, or switch to another mode).
            vi. **SKIP to Step 8 (QA Command Precedence Check & End of VAN for this task).**
        *   **If NO (Problem is not immediately obvious/simple, or any uncertainty, or fails any strict criteria):**
            i.  State: "Initial triage indicates further analysis is needed or the task is more complex than a quick fix. Proceeding with standard VAN initialization."
            ii. Proceed to Step 3.

3.  **Platform Detection (Sub-Rule - Standard VAN Path):**
    a.  State: "Performing platform detection."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-platform-detection.mdc`.
    c.  (This fetched rule will guide OS detection and logging to `activeContext.md`).

4.  **File Verification & Creation (Memory Bank Setup) (Sub-Rule - Standard VAN Path):**
    a.  State: "Performing Memory Bank file verification and setup."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/file-verification.mdc`.
    c.  (This fetched rule guides creating/verifying `memory-bank/` structure and core files).

5.  **Full Context Analysis & Complexity Determination (Sub-Rule - Standard VAN Path):**
    a.  State: "Performing detailed context analysis and determining task complexity."
    b.  `read_file` relevant project files (README, main source files, etc.) as needed for a broader understanding.
    c.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/complexity-decision-tree.mdc`.
    d.  (This fetched rule guides assessing Level 1-4 and updating `activeContext.md` and `tasks.md`).
    e.  `read_file memory-bank/activeContext.md` to confirm the determined complexity level.

6.  **Mode Transition based on Complexity (Standard VAN Path):**
    a.  **If Level 1 determined (and not handled by Quick Triage):**
        i.  State: "Task assessed as Level 1. Completing VAN initialization."
        ii. Use `edit_file` to update `memory-bank/activeContext.md` with: "VAN Process Status: Level 1 Initialization Complete. Task ready for IMPLEMENT mode."
        iii. State: "VAN Initialization Complete for Level 1 task [Task Name]. Recommend IMPLEMENT mode." Await user.
    b.  **If Level 2, 3, or 4 determined:**
        i.  State: "ðŸš« LEVEL [2/3/4] TASK DETECTED: [Task Name]. This task REQUIRES detailed planning."
        ii. State: "Transitioning to PLAN mode is necessary. Type 'PLAN' to proceed with planning." Await user.

7.  **VAN QA - Technical Validation (Entry point if "VAN QA" was typed, or if called after CREATIVE mode by user):**
    a.  State: "Initiating VAN QA Technical Validation."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-qa-main.mdc`.
    c.  (This rule handles the QA process). Await user action based on QA report.

8.  **QA COMMAND PRECEDENCE (If user types "QA" during steps 3-6 of Standard VAN Initialization):**
    a.  State: "General QA command received, pausing current VAN initialization step ([current step])."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/qa-mode-map.mdc`.
    c.  After general QA is complete: State "Resuming VAN initialization." Continue from paused step.
```

---

### 4. Refining Complexity Level Definitions

Your ideas for complexity levels, especially incorporating codebase size and the nature of "refinement/iteration," are excellent. The current definitions are a bit too generic. Let's refine `Core/complexity-decision-tree.mdc` to align with your vision and provide clearer guidance for the AI.

**Required Changes to `cursor-memory-bank/.cursor/rules/isolation_rules/Core/complexity-decision-tree.mdc`:**

I will provide the *entire new content* for this file.

```markdown
---
description: Core rule for AI to determine task complexity (Level 1-4) and initiate appropriate workflow using Memory Bank principles.
globs: **/Core/complexity-decision-tree.mdc
alwaysApply: false
---
# TASK COMPLEXITY DETERMINATION

> **TL;DR:** This rule guides you to determine the appropriate complexity level (1-4) for the current task. Based on the level, you will then be instructed to `fetch_rules` for the corresponding primary mode map (e.g., for PLAN or IMPLEMENT).

## ðŸŒ³ COMPLEXITY DECISION TREE (Conceptual for AI)

This decision tree guides you through determining the complexity level of a new task.

**Decision Flow:**
1.  **Start: New Task**
2.  **Is it a bug fix or error correction?**
    *   If "Yes":
        *   "Affects single file, simple fix, < 30 min coding, no design decisions?":
            *   If "Yes": **Level 1 (Quick Bug Fix)**
            *   If "No": "Affects multiple files/components, requires minor analysis, up to 1 day effort?":
                *   If "Yes": **Level 2 (Simple Bug Fix/Refinement)**
                *   If "No": "Requires significant analysis, architectural impact, or deep iteration on medium-large codebase?":
                    *   If "Yes": **Level 3 (Intermediate Bug Fix/Feature)**
                    *   If "No": (Default to Level 3 if complex bug, but not L4 system-wide)
    *   If "No": (It's a new feature or enhancement)
        *   "Is it a small, self-contained addition to an existing component, up to 1 day effort?":
            *   If "Yes": **Level 2 (Simple Enhancement)**
            *   If "No": "Is it a new feature involving multiple components, requiring design decisions, or deep iteration on a medium-large codebase?":
                *   If "Yes": **Level 3 (Intermediate Feature)**
                *   If "No": "Is it a system-wide change, new major subsystem, or building a new program from scratch on a very large/enterprise codebase?":
                    *   If "Yes": **Level 4 (Complex System/Enterprise)**
                    *   If "No": (Default to Level 3 if complex feature, but not L4 systemic)

**Textual Guide for AI:**
Based on the user's request and your initial analysis (e.g., from reading `README.md` or a high-level task description):

1.  **Is the task primarily a bug fix or error correction?**
    *   **Yes:**
        *   Does it affect only a single file, is the fix immediately apparent (e.g., typo, simple logic error), takes less than 30 minutes of direct coding, and requires no design decisions or new dependencies? -> **Level 1 (Quick Bug Fix)**
        *   Does it affect multiple files/components, require some minor analysis, and is expected to take up to 1 day of effort? -> **Level 2 (Simple Bug Fix/Refinement)**
        *   Does it require significant analysis, potentially impact architecture, involve deep iteration, or is on a medium-large codebase (e.g., open-source project)? -> **Level 3 (Intermediate Bug Fix/Feature)**
    *   **No (likely a new feature or enhancement):**
        *   Is it a small, self-contained addition or modification to an existing component, expected to take up to 1 day of effort? -> **Level 2 (Simple Enhancement)**
        *   Is it a complete new feature involving multiple new/existing components, requiring design decisions, deep iteration, or is on a medium-large codebase (e.g., open-source project)? -> **Level 3 (Intermediate Feature)**
        *   Is it a system-wide change, a new major subsystem, or building a new program/application from scratch, especially on a very large codebase (e.g., enterprise application)? -> **Level 4 (Complex System/Enterprise)**

## ðŸ“Š COMPLEXITY LEVEL INDICATORS (Refined)

Use these indicators to help determine task complexity:

### Level 1: Quick Bug Fix
-   **Description:** Easy and fast bug fix, typically involving a single file modification.
-   **Keywords:** "fix typo", "correct variable", "small error", "UI alignment", "broken link", "hotfix".
-   **Scope:** Single file, isolated function, minor UI element.
-   **Effort/Time:** Very fast (minutes to <30 minutes direct coding).
-   **Risk:** Very low, isolated.
-   **Process:** Direct implementation, minimal documentation.

### Level 2: Simple Enhancement / Simple Bug Fix & Refinement
-   **Description:** Easy task or bug fix that might take longer, requiring some refinement or iteration. Adding easy, self-contained features.
-   **Keywords:** "add simple feature", "improve validation", "update styling", "refactor small module", "fix minor bug across components".
-   **Scope:** Single component or a few closely related files/components.
-   **Effort/Time:** Hours to 1 day. May involve a few iterations.
-   **Risk:** Low to moderate, contained.
-   **Process:** Basic planning, direct implementation, basic reflection.

### Level 3: Intermediate Feature / Medium-Complex Error on Medium-Large Codebase
-   **Description:** Medium-complex task that requires comprehensive planning and may need dedicated creative design phases. Could involve initializing a new, moderately sized app/program from scratch, or fixing/modifying a complex error in an open-source or medium-large codebase.
-   **Keywords:** "implement user auth", "create dashboard", "develop search functionality", "build user profile system", "integrate third-party API", "fix complex data flow", "refactor major module", "build new app prototype".
-   **Scope:** Multiple components, new distinct functionality, or significant changes across a subsystem. Often involves interaction with existing systems.
-   **Effort/Time:** Days to 1-2 weeks. Requires iterative refinement and design exploration.
-   **Codebase Size:** Medium to large (e.g., typical open-source project, internal application).
-   **Risk:** Moderate to significant, affects multiple areas.
-   **Process:** Comprehensive planning, mandatory creative phases (if design needed), systematic implementation, detailed reflection, intermediate archiving.

### Level 4: Complex System / Enterprise Application Modification/Fix
-   **Description:** Highly complex task or modifying/fixing a complex error on a very large codebase, such as an enterprise application. Could involve building a new system/application from scratch that has significant architectural implications.
-   **Keywords:** "architect new platform", "design microservices", "implement payment processing framework", "major system refactor", "integrate multiple enterprise systems", "build new application from scratch (large scale)".
-   **Scope:** Multiple subsystems, entire application, or deep architectural redesign. System-wide impact.
-   **Effort/Time:** Weeks to months. Requires phased implementation.
-   **Codebase Size:** Very large (e.g., enterprise application, large-scale platform).
-   **Risk:** High, architectural implications, potential for systemic issues.
-   **Process:** Comprehensive planning (including architectural), multiple mandatory creative phases, phased implementation, comprehensive reflection, comprehensive archiving.

## ðŸ” COMPLEXITY ASSESSMENT QUESTIONS

Answer these questions to determine complexity:

1. **Scope Impact**
   - How many files/components/subsystems will need to be modified or created?
   - Are there system-wide implications or external integrations?
   - What is the size/type of the codebase (small script, medium open-source, large enterprise)?

2. **Design Decisions**
   - Are complex design decisions required (e.g., architectural patterns, new algorithms, significant UI/UX flows)?
   - Will it require dedicated creative phases for design exploration?

3. **Risk Assessment**
   - What is the potential impact if the task fails (e.g., data loss, downtime, security vulnerability)?
   - Will it affect critical functionality or user experience?

4. **Implementation Effort & Iteration**
   - How long is it expected to take to implement and test thoroughly?
   - Is significant iteration, refinement, or phased delivery anticipated?

## ðŸ“Š KEYWORD ANALYSIS TABLE

| Keyword | Likely Level | Notes |
|---------|--------------|-------|
| "Fix typo", "UI tweak" | Level 1 | Very fast, isolated |
| "Fix small bug", "Correct variable" | Level 1 | Simple, single file |
| "Add simple feature" | Level 2 | Self-contained, minor impact |
| "Improve validation", "Refactor small" | Level 2 | Contained changes, some iteration |
| "Implement user auth", "Build dashboard" | Level 3 | New functionality, multiple components, design needed |
| "Fix complex data flow", "Refactor major" | Level 3 | Significant analysis, iterative fixes |
| "Architect new system", "Design microservices" | Level 4 | System-wide, deep architectural changes |
| "Build app from scratch (large)", "Enterprise integration" | Level 4 | Extensive effort, high risk, phased delivery |

## ðŸ”„ COMPLEXITY ESCALATION

If during a task you discover it's more complex than initially determined:

```
âš ï¸ TASK ESCALATION NEEDED
Current Level: Level [X]
Recommended Level: Level [Y]
Reason: [Brief explanation]

Would you like me to escalate this task to Level [Y]?
```

If approved, switch to the appropriate higher-level process map.

## ðŸŽ¯ PROCESS SELECTION

After determining complexity, load the appropriate process map:

| Level | Description | Process Map |
|-------|-------------|-------------|
| 1 | Quick Bug Fix | `.cursor/rules/isolation_rules/Level1/workflow-level1.mdc` (or `optimized-workflow-level1.mdc`) |
| 2 | Simple Enhancement | `.cursor/rules/isolation_rules/Level2/workflow-level2.mdc` |
| 3 | Intermediate Feature | `.cursor/rules/isolation_rules/Level3/workflow-level3.mdc` |
| 4 | Complex System | `.cursor/rules/isolation_rules/Level4/workflow-level4.mdc` |

## ðŸ“ COMPLEXITY DETERMINATION TEMPLATE

Use this template to document complexity determination:

```
## COMPLEXITY DETERMINATION

Task: [Task description]

Assessment:
- Scope: [Single file/component, Multiple files/components, Subsystem, System-wide]
- Codebase Size: [Small (script/single app), Medium (open-source), Large (enterprise)]
- Design decisions: [None, Simple, Moderate, Complex]
- Risk: [Very Low, Low, Moderate, Significant, High]
- Implementation effort: [Minutes, Hours, Days, Weeks, Months]
- Iteration/Refinement: [None, Minor, Moderate, Extensive]

Keywords identified: [List relevant keywords]

Determination: Level [1/2/3/4] - [Quick Bug Fix/Simple Enhancement/Intermediate Feature/Complex System]

Loading process map: [Level X Map Path]
```

## ðŸ“ ACTION: DOCUMENT & ANNOUNCE COMPLEXITY

1.  **Determine Level:** Decide Level 1, 2, 3, or 4.
2.  **Document in `activeContext.md`:** Use `edit_file` to update `memory-bank/activeContext.md`:
    ```markdown
    ## Task Complexity Assessment
    - Task: [User's request]
    - Determined Complexity: Level [1/2/3/4] - [Name]
    - Rationale: [Justification]
    ```
3.  **Update `tasks.md`:** Use `edit_file` to update `memory-bank/tasks.md` with the level, e.g., `Level 3: Implement user auth`.
4.  **Announce & Next Step:**
    *   State: "Assessed as Level [N]: [Name]."
    *   **If Level 1:** "Proceeding with Level 1 workflow. Will `fetch_rules` for `.cursor/rules/isolation_rules/Level1/workflow-level1.mdc` (or directly to IMPLEMENT map if simple enough, e.g., `visual-maps/implement-mode-map.mdc` which might then fetch a Level 1 implement rule)."
    *   **If Level 2, 3, or 4:** "Requires detailed planning. Transitioning to PLAN mode. Will `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/plan-mode-map.mdc`."
```