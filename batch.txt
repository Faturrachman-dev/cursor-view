import os

# --- Define your MDC file data here ---
MDC_FILES_DATA = [
    # We will populate this list
]

def create_or_update_mdc_file(filepath, description, globs, always_apply, body_content):
    """Creates or updates an .mdc file with the given frontmatter and body."""
    
    always_apply_str = 'true' if always_apply else 'false'
    
    # Handle globs: if it's a simple string without special YAML chars,
    # it doesn't need quotes. If it has them, it's likely intentional.
    # For simplicity here, we'll assume your globs are simple enough not to need explicit quoting.
    # If a glob pattern *itself* contains characters that YAML would interpret specially,
    # then it *should* be quoted in the MDC_FILES_DATA string.
    # The key is that the Python script doesn't ADD extra quotes if not needed.
    
    frontmatter = f"""---
description: {description}
globs: {globs} 
alwaysApply: {always_apply_str}
---
"""
    
    full_content = frontmatter + body_content.strip()

    try:
        dir_name = os.path.dirname(filepath)
        if dir_name and not os.path.exists(dir_name):
            os.makedirs(dir_name, exist_ok=True)
            print(f"Created directory: {dir_name}")

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(full_content)
        print(f"Successfully created/updated: {filepath}")
    except Exception as e:
        print(f"Error writing file {filepath}: {e}")

if __name__ == "__main__":
    # Add refined Core rules first
    MDC_FILES_DATA.extend([
        {
            "path": ".cursor/rules/isolation_rules/Core/command-execution.mdc",
            "description": "Core guidelines for AI command execution, emphasizing tool priority (edit_file, fetch_rules, run_terminal_cmd), platform awareness, and result documentation within the Memory Bank system.",
            "globs": "**/Core/command-execution.mdc",
            "alwaysApply": False,
            "body": """
# COMMAND EXECUTION SYSTEM

> **TL;DR:** This system provides guidelines for efficient and reliable command and tool usage. Prioritize `edit_file` for file content, `fetch_rules` for loading `.mdc` rules, and `run_terminal_cmd` for execution tasks. Always document actions and results in `memory-bank/activeContext.md`.

## ðŸ› ï¸ TOOL PRIORITY & USAGE

1.  **`edit_file` (Primary for Content):**
    *   Use for ALL creation and modification of `.md` files in `memory-bank/` and `documentation/`.
    *   Use for ALL source code modifications.
    *   `edit_file` can create a new file if it doesn't exist and populate it.
    *   Provide clear instructions or full content blocks for `edit_file`.
2.  **`fetch_rules` (Primary for `.mdc` Rules):**
    *   Use to load and follow instructions from other `.mdc` rule files within `.cursor/rules/isolation_rules/`.
    *   Specify the full path to the target `.mdc` file.
3.  **`read_file` (Primary for Context Gathering):**
    *   Use to read existing project files (source code, `README.md`), `memory-bank/*.md` files for context, or `.mdc` files if `fetch_rules` is not appropriate for the specific need (e.g., just extracting a template).
4.  **`run_terminal_cmd` (Primary for Execution):**
    *   Use for tasks like `mkdir`, running tests, build scripts, or starting servers.
    *   **CRITICAL:** Be platform-aware (see "Platform-Specific Considerations" below). If unsure of the OS, state your default command (e.g., for Linux) and ask for the Windows PowerShell equivalent if needed.
5.  **`list_dir`, `search_files`, `codebase_search`:**
    *   Use for file system exploration and code/text searching as appropriate.

## ðŸ” COMMAND EFFICIENCY & PLANNING WORKFLOW (Conceptual for AI)
```mermaid
graph TD
    Start["Command Planning"] --> Analyze["Analyze Requirements"]
    Analyze --> ToolSelect["Select Correct Tool<br>(edit_file, fetch_rules, run_terminal_cmd, etc.)"]
    ToolSelect --> Complexity{"Action Complexity?"}
    Complexity -->|"Simple File Edit"| SingleEdit["Use `edit_file` directly"]
    Complexity -->|"Simple Terminal Cmd"| SingleCmd["Use `run_terminal_cmd`"]
    Complexity -->|"Complex Sequence"| GroupedSteps["Break into Logical Textual Steps<br>using appropriate tools for each step"]
    SingleEdit & SingleCmd & GroupedSteps --> Verify["Verify Results<br>(e.g., `read_file` back, check terminal output)"]
    Verify --> Document["Document Action & Result<br>in `activeContext.md` using `edit_file`"]
    Document --> Next["Next Action"]
```
**Textual Guide for AI:**
1.  **Analyze Requirements:** Understand what needs to be achieved.
2.  **Select Correct Tool:** Choose `edit_file` for content, `fetch_rules` for rules, `run_terminal_cmd` for execution, etc.
3.  **Execute:** Perform the action. For complex sequences, break it down into clear, tool-specific steps.
4.  **Verify Results:** If you used `edit_file`, consider using `read_file` to confirm the content. If `run_terminal_cmd`, examine the output.
5.  **Document Action & Result:** Use `edit_file` to append a summary of the command/tool call and its outcome to the "Build Log" or relevant section in `memory-bank/activeContext.md`.

## ðŸš¦ DIRECTORY VERIFICATION (for `run_terminal_cmd`)
**Textual Guide for AI:**
1.  Before running build scripts or package manager commands (npm, pip) via `run_terminal_cmd`, verify you are in the correct project root directory.
2.  Use `list_dir` to check for key files like `package.json` or `requirements.txt`.
3.  If not in the correct directory, use `run_terminal_cmd` with `cd [path_to_project_root]` to navigate.

## ðŸ“‹ COMMAND DOCUMENTATION TEMPLATE (for `activeContext.md` "Build Log")
When documenting your actions, use `edit_file` to append entries like this to `memory-bank/activeContext.md`:
```markdown
### Action: [Purpose of the action]
- **Tool Used:** `[edit_file | fetch_rules | run_terminal_cmd | etc.]`
- **Target/Command:** `[file_path | rule_path | actual_terminal_command]`
- **Parameters (if applicable):** `[e.g., content for edit_file, search query]`
- **Expected Outcome:** `[Briefly what you expected]`
- **Actual Result:**
  \`\`\`
  [Output from run_terminal_cmd, or confirmation of file edit/read]
  \`\`\`
- **Effect:** `[Brief description of what changed in the system or Memory Bank]`
- **Next Steps:** `[What you plan to do next]`
```

## ðŸ” PLATFORM-SPECIFIC CONSIDERATIONS (for `run_terminal_cmd`)
**Textual Guide for AI:**
*   **Windows (PowerShell):** Path separator: `\`, Dir creation: `mkdir my_dir` or `New-Item -ItemType Directory -Path my_dir`.
*   **Unix/Linux/Mac (Bash/Zsh):** Path separator: `/`, Dir creation: `mkdir -p my_dir`.
*   **Action:** If unsure of OS, state default (Linux) and ask for Windows PowerShell equivalent or user OS specification.

## ðŸ“ COMMAND EXECUTION CHECKLIST (AI Self-Correction)
- Purpose clear? Correct tool chosen? Platform considerations for `run_terminal_cmd`? Action/result documented in `activeContext.md` via `edit_file`? Outcome verified?

## ðŸš¨ WARNINGS
*   Avoid `run_terminal_cmd` with `echo > file` or `Add-Content` for multi-line content. **Always use `edit_file`**.
*   For destructive `run_terminal_cmd` (e.g., `rm`), seek user confirmation.
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/complexity-decision-tree.mdc",
            "description": "Core rule for AI to determine task complexity (Level 1-4) and initiate appropriate workflow using Memory Bank principles.",
            "globs": "**/Core/complexity-decision-tree.mdc",
            "alwaysApply": False,
            "body": """
# TASK COMPLEXITY DETERMINATION

> **TL;DR:** This rule guides you to determine task complexity (Level 1-4). Based on the level, you will then be instructed to `fetch_rules` for the corresponding primary mode map.

## ðŸŒ³ COMPLEXITY DECISION TREE (Conceptual for AI)
**Textual Guide for AI:**
Based on user's request and initial analysis (e.g., from `read_file` on `README.md`):

1.  **Bug fix/error correction?**
    *   **Yes:** Single, isolated component? -> **Level 1 (Quick Bug Fix)**
    *   **Yes:** Multiple components, straightforward fix? -> **Level 2 (Simple Enhancement/Refactor)**
    *   **Yes:** Complex interactions, architectural impact? -> **Level 3 (Intermediate Feature/Bug)**
    *   **No (new feature/enhancement):**
        *   Small, self-contained addition? -> **Level 2 (Simple Enhancement)**
        *   Complete new feature, multiple components, needs design? -> **Level 3 (Intermediate Feature)**
        *   System-wide, major subsystem, deep architectural design? -> **Level 4 (Complex System)**

## ðŸ“ ACTION: DOCUMENT & ANNOUNCE COMPLEXITY

1.  **Determine Level:** Decide Level 1, 2, 3, or 4.
2.  **Document in `activeContext.md`:** Use `edit_file` to update `memory-bank/activeContext.md`:
    ```markdown
    ## Task Complexity Assessment
    - Task: [User's request]
    - Determined Complexity: Level [1/2/3/4] - [Name]
    - Rationale: [Justification]
    ```
3.  **Update `tasks.md`:** Use `edit_file` to update `memory-bank/tasks.md` with the level, e.g., `Level 3: Implement user auth`.
4.  **Announce & Next Step:**
    *   State: "Assessed as Level [N]: [Name]."
    *   **Level 1:** "Proceeding with Level 1 workflow. Will `fetch_rules` for `.cursor/rules/isolation_rules/Level1/workflow-level1.mdc` (or directly to IMPLEMENT map)."
    *   **Level 2-4:** "Requires detailed planning. Transitioning to PLAN mode. Will `fetch_rules` for `.cursor/rules/isolation_rules/visual-maps/plan-mode-map.mdc`."
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/creative-phase-enforcement.mdc",
            "description": "Core rule for enforcing Creative Phase completion for Level 3-4 tasks before allowing IMPLEMENT mode.",
            "globs": "**/Core/creative-phase-enforcement.mdc",
            "alwaysApply": False,
            "body": """
# CREATIVE PHASE ENFORCEMENT

> **TL;DR:** For L3/L4 tasks, if `tasks.md` flags items for "CREATIVE Phase", they MUST be completed before IMPLEMENT.

## ðŸ” ENFORCEMENT WORKFLOW (AI Actions)
(Typically invoked by IMPLEMENT mode orchestrator for L3/L4 tasks)

1.  **Check Task Level & Creative Flags:**
    a.  `read_file` `memory-bank/activeContext.md` (for task level).
    b.  `read_file` `memory-bank/tasks.md`. Scan current feature's sub-tasks for incomplete "CREATIVE: Design..." entries.
2.  **Decision:**
    *   **If uncompleted CREATIVE tasks for L3/L4 feature:**
        a.  State: "ðŸš¨ IMPLEMENTATION BLOCKED for [feature]. Creative designs needed for: [list uncompleted creative tasks]."
        b.  Suggest: "Initiate CREATIVE mode (e.g., 'CREATIVE design [component]')." Await user.
    *   **Else (No uncompleted creative tasks or not L3/L4):**
        a.  State: "Creative phase requirements met/not applicable. Proceeding."
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/creative-phase-metrics.mdc",
            "description": "Core reference on metrics and quality assessment for Creative Phase outputs. For AI understanding of quality expectations.",
            "globs": "**/Core/creative-phase-metrics.mdc",
            "alwaysApply": False,
            "body": """
# CREATIVE PHASE METRICS & QUALITY ASSESSMENT (AI Guidance)

> **TL;DR:** This outlines quality expectations for `creative-*.md` documents. Use this as a guide when generating or reviewing creative outputs.

## ðŸ“Š QUALITY EXPECTATIONS FOR `creative-*.md` (AI Self-Guide)
A good `memory-bank/creative/creative-[feature_name].md` (created/updated via `edit_file`) should cover:
1.  **Problem & Objectives:** Clearly defined.
2.  **Requirements & Constraints:** Addressed by the design.
3.  **Options Explored:** Multiple (2-3) viable design options considered.
4.  **Analysis:** Pros/cons, feasibility for each option.
5.  **Justification:** Recommended design clearly justified.
6.  **Implementation Guidelines:** Provided for the chosen design.
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/file-verification.mdc",
            "description": "Core rule for AI to verify and create Memory Bank file structures, prioritizing `edit_file` for content and `run_terminal_cmd` for `mkdir`.",
            "globs": "**/Core/file-verification.mdc",
            "alwaysApply": False,
            "body": """
# OPTIMIZED FILE VERIFICATION & CREATION SYSTEM

> **TL;DR:** Verify/create Memory Bank structure. Use `edit_file` for files with content, `run_terminal_cmd` (platform-aware) for `mkdir`.

## ðŸš¨ CRITICAL: MEMORY BANK VERIFICATION (Early VAN)

1.  **Verify/Create `memory-bank/` Directory:**
    a.  `list_dir` project root.
    b.  If missing, `run_terminal_cmd` (`mkdir memory-bank`). Confirm.
2.  **Verify/Create Subdirectories (`archive`, `creative`, `reflection`):**
    a.  `list_dir` `memory-bank/`.
    b.  For each missing, `run_terminal_cmd` (e.g., `mkdir memory-bank/archive`). Confirm.
3.  **Verify/Create Core `.md` Files (Using `edit_file`):**
    a.  For each core file in `Core/memory-bank-paths.mdc` (e.g., `tasks.md`):
        i.  `read_file` `memory-bank/[filename].md` to check existence/content.
        ii. If new/empty, `edit_file` `memory-bank/[filename].md` with initial template (see refined VAN instructions for templates).
        iii. Optionally `read_file` again to confirm.
4.  **Log Verification:** `edit_file` `memory-bank/activeContext.md` with a "File Verification Log" summarizing actions. If critical creation failed, state this.
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/hierarchical-rule-loading.mdc",
            "description": "Core design principle for Memory Bank: hierarchical/lazy loading of `.mdc` rules via `fetch_rules`.",
            "globs": "**/Core/hierarchical-rule-loading.mdc",
            "alwaysApply": False, # Design principle
            "body": """
# HIERARCHICAL RULE LOADING SYSTEM (Design Principle for AI)

> **TL;DR:** You achieve hierarchical/lazy rule loading by following instructions in main mode prompts or other `.mdc` rules that direct you to use `fetch_rules` to load specific `.mdc` rule files only when needed.

## ðŸ§  HOW YOU EXECUTE HIERARCHICAL LOADING:
1.  **Mode Activation:** Your main custom prompt for a mode (e.g., VAN) tells you to `fetch_rules` for its primary orchestrating `.mdc` (e.g., `visual-maps/van-mode-map.mdc`).
2.  **Following Instructions:** That `.mdc` guides you. Some steps might instruct: "If [condition], then `fetch_rules` to load and follow `[specific_sub_rule.mdc]`."
3.  **Current Rule Focus:** Always operate based on the instructions from the most recently fetched and relevant rule.
4.  **Acknowledge Fetches:** When you `fetch_rules` for an `.mdc`, briefly state: "Fetched `[rule_path]`. Now proceeding with its instructions."
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/memory-bank-paths.mdc",
            "description": "Defines canonical paths for core Memory Bank files and directories. CRITICAL reference for all file operations.",
            "globs": "**/Core/memory-bank-paths.mdc",
            "alwaysApply": True, # Fundamental reference
            "body": """
# CORE MEMORY BANK FILE & DIRECTORY LOCATIONS

**CRITICAL REFERENCE:** Adhere strictly to these paths for all file operations (`edit_file`, `read_file`, `list_dir`, `run_terminal_cmd` for `mkdir`).

## Root Memory Bank Directory:
*   `memory-bank/` (at project root)

## Core `.md` Files (in `memory-bank/`):
*   Tasks: `memory-bank/tasks.md`
*   Active Context: `memory-bank/activeContext.md`
*   Progress: `memory-bank/progress.md`
*   Project Brief: `memory-bank/projectbrief.md`
*   Product Context: `memory-bank/productContext.md`
*   System Patterns: `memory-bank/systemPatterns.md`
*   Tech Context: `memory-bank/techContext.md`
*   Style Guide: `memory-bank/style-guide.md`

## Subdirectories in `memory-bank/`:
*   Creative: `memory-bank/creative/` (Files: `creative-[feature_or_component_name].md`)
*   Reflection: `memory-bank/reflection/` (Files: `reflect-[task_id_or_feature_name]-[date].md`)
*   Archive: `memory-bank/archive/` (Files: `archive-[task_id_or_feature_name]-[date].md`)

## Project Documentation Directory (Separate):
*   `documentation/` (at project root)

## AI Verification Mandate:
*   Before `edit_file` on Memory Bank artifacts, confirm path starts with `memory-bank/` or its subdirectories.
*   When creating new core files, use `edit_file` with exact path (e.g., `memory-bank/tasks.md`).
*   For `run_terminal_cmd mkdir`, ensure correct target paths.
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/mode-transition-optimization.mdc",
            "description": "Core design principles for optimized mode transitions using `activeContext.md` as the handover document.",
            "globs": "**/Core/mode-transition-optimization.mdc",
            "alwaysApply": False, # Design principle
            "body": """
# MODE TRANSITION OPTIMIZATION (AI Actions)

> **TL;DR:** Efficient mode transitions are achieved by updating `memory-bank/activeContext.md` (via `edit_file`) before a transition. The next mode's orchestrator rule then reads this file for context.

## ðŸ”„ CONTEXT TRANSFER PROCESS (AI Actions):

1.  **Before Current Mode Exits (or suggests exiting):**
    a.  Your current instructions (from main prompt or an `.mdc` via `fetch_rules`) will guide you to use `edit_file` to update `memory-bank/activeContext.md`.
    b.  This update should include a section like:
        ```markdown
        ## Mode Transition Prepared
        - From Mode: [Current Mode]
        - To Mode: [Recommended Target Mode]
        - Task: [Current Task Name]
        - Key Output from [Current Mode]: [Summary of outputs/decisions]
        - Focus for [Target Mode]: [Primary goal for next mode]
        ```
2.  **When New Mode Starts:**
    a.  The new mode's main custom prompt will instruct you to `fetch_rules` for its primary orchestrating `.mdc` file.
    b.  That orchestrating `.mdc` will (as an early step) instruct you to `read_file` `memory-bank/activeContext.md` to understand the incoming context and focus.

**Key Principle:** `activeContext.md` is the primary "handover document" between modes, managed by `edit_file`.
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/optimization-integration.mdc",
            "description": "Design overview of Memory Bank optimization strategies. For AI understanding of system goals.",
            "globs": "**/Core/optimization-integration.mdc",
            "alwaysApply": False, # Design overview
            "body": """
# MEMORY BANK OPTIMIZATION INTEGRATION (AI Understanding)

> **TL;DR:** You enact Memory Bank optimizations by following specific instructions from other rule files that guide hierarchical rule loading, adaptive complexity, and progressive documentation.

## ðŸ”„ HOW YOU ACHIEVE OPTIMIZATIONS:
You don't "run" an optimization integration flow. You achieve system optimizations by:
1.  **Hierarchical Rule Loading:** Following `fetch_rules` instructions in main prompts and other `.mdc` files to load only necessary rules when they are needed.
2.  **Adaptive Complexity Model:** Following `Core/complexity-decision-tree.mdc` (when fetched in VAN mode) and then loading level-specific rules as directed by subsequent instructions.
3.  **Dynamic Context Management:** Diligently using `read_file` to get context from, and `edit_file` to update, `memory-bank/activeContext.md`, `tasks.md`, and `progress.md`.
4.  **Transition Optimization:** Following the process in `Core/mode-transition-optimization.mdc` (i.e., updating `activeContext.md` before a mode switch).
5.  **Creative Phase Optimization:** Using the `Phases/CreativePhase/optimized-creative-template.mdc` (when fetched in CREATIVE mode).

**This document explains the *design goals*. Your role is to execute the specific, actionable instructions in other `.mdc` files, which collectively achieve these optimizations.**
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/Core/platform-awareness.mdc",
            "description": "Core guidelines for platform-aware command execution with `run_terminal_cmd`.",
            "globs": "**/Core/platform-awareness.mdc",
            "alwaysApply": True, # Fundamental for terminal use
            "body": """
# PLATFORM AWARENESS SYSTEM (for `run_terminal_cmd`)

> **TL;DR:** When using `run_terminal_cmd`, be aware of OS differences. If unsure, state your default command and ask for the platform-specific version or user's OS.

## ðŸ” AI ACTION FOR PLATFORM AWARENESS:

1.  **Identify Need for `run_terminal_cmd`:** For tasks like `mkdir`, running scripts, etc.
2.  **Consider Platform:**
    *   **Path Separators:** `/` (Linux/macOS) vs. `\` (Windows).
    *   **Common Commands:**
        *   `mkdir -p path/to/dir` (Linux/macOS) vs. `mkdir path\to\dir` (Windows PowerShell).
        *   `ls -la` (Linux/macOS) vs. `Get-ChildItem` or `dir` (Windows PowerShell).
3.  **Execution Strategy:**
    a.  If the OS is known (e.g., from user, or `techContext.md`), use the appropriate command.
    b.  If OS is unknown:
        i.  State your default command (e.g., "I will use `mkdir -p my/folder` for Linux.").
        ii. Ask: "Is this correct for your OS, or should I use a different command (e.g., for Windows PowerShell)?"
    c.  When executing, clearly state the full command you are running.
4.  **Document:** Log the command and its output in `memory-bank/activeContext.md` using `edit_file`.

**This is a guiding principle. The key is to be *aware* of potential differences and adapt `run_terminal_cmd` usage or seek clarification.**
"""
        }
    ])

    # Now add visual-maps related .mdc files
    # (You will need to meticulously create these dictionary entries with refined bodies)
    MDC_FILES_DATA.extend([
        {
            "path": ".cursor/rules/isolation_rules/visual-maps/archive-mode-map.mdc",
            "description": "Orchestrates ARCHIVE mode, guiding creation of archive docs and Memory Bank updates. Fetched when ARCHIVE process starts.",
            "globs": "**/visual-maps/archive-mode-map.mdc",
            "alwaysApply": False,
            "body": """
# ARCHIVE MODE: TASK DOCUMENTATION PROCESS MAP (AI Instructions)

> **TL;DR:** Finalize task documentation, create archive record, update Memory Bank. Use `edit_file` for all docs.

## ðŸ§­ ARCHIVE MODE PROCESS FLOW (AI Actions)

1.  **Acknowledge & Context:**
    a.  State: "Initiating ARCHIVE for [Task - from activeContext.md/tasks.md]."
    b.  `read_file`: `memory-bank/tasks.md` (for task details, complexity).
    c.  `read_file`: `memory-bank/reflection/reflect-[task_id_or_feature_name]-[date].md`.
    d.  `read_file`: `memory-bank/progress.md`, `memory-bank/activeContext.md`.
2.  **Fetch Level-Specific Archive Rule (based on complexity from `tasks.md`):**
    *   L1: `fetch_rules` for `.cursor/rules/isolation_rules/Level1/archive-minimal.mdc`.
    *   L2: `fetch_rules` for `.cursor/rules/isolation_rules/Level2/archive-basic.mdc`.
    *   L3: `fetch_rules` for `.cursor/rules/isolation_rules/Level3/archive-intermediate.mdc`.
    *   L4: `fetch_rules` for `.cursor/rules/isolation_rules/Level4/archive-comprehensive.mdc`.
3.  **Follow Fetched Rule:** The level-specific rule will guide creating the archive document (using `edit_file`) and performing final Memory Bank updates (`tasks.md`, `progress.md`, `activeContext.md` reset) using `edit_file`.
4.  **Notify Completion:** State: "ARCHIVING COMPLETE for [Task]. Archive: `[path]`. Suggest VAN mode for next task."

## ðŸ“Š PRE-ARCHIVE CHECK (AI Self-Check)
1.  `tasks.md`: Reflection complete for current task?
2.  `memory-bank/reflection/reflect-[...].md`: Exists and finalized?
3.  `progress.md`: Updated for IMPLEMENT/REFLECT phases?
(If fails, suggest returning to REFLECT.)
"""
        },
        {
            "path": ".cursor/rules/isolation_rules/visual-maps/creative-mode-map.mdc",
            "description": "Orchestrates CREATIVE mode, guiding design for components flagged in tasks.md. Fetched by PLAN mode.",
            "globs": "**/visual-maps/creative-mode-map.mdc",
            "alwaysApply": False,
            "body": """
# CREATIVE MODE: DESIGN PROCESS MAP (AI Instructions)

> **TL;DR:** Facilitate design for components in `tasks.md`. Use `fetch_rules` for design-type guidance, `edit_file` for docs.

## ðŸ§­ CREATIVE MODE PROCESS FLOW (AI Actions)

1.  **Acknowledge & Context:**
    a.  State: "OK CREATIVE. Identifying components for design."
    b.  `read_file`: `memory-bank/tasks.md` (for "CREATIVE: Design..." tasks).
    c.  `read_file`: `memory-bank/activeContext.md` (for project context).
    d.  If no CREATIVE tasks, state and await instruction.
2.  **For each "CREATIVE: Design..." task:**
    a.  Announce: "CREATIVE phase for: [Component] - Type: [Arch/Algo/UI-UX]."
    b.  **Fetch Design-Type Rule:**
        *   Arch: `fetch_rules` for `.cursor/rules/isolation_rules/Phases/CreativePhase/creative-phase-architecture.mdc`.
        *   Algo: `fetch_rules` for `.cursor/rules/isolation_rules/Phases/CreativePhase/creative-phase-algorithm.mdc`.
        *   UI/UX: `fetch_rules` for `.cursor/rules/isolation_rules/Phases/CreativePhase/creative-phase-uiux.mdc`.
    c.  **Follow Fetched Rule:** Generate design doc content (requirements, options, analysis, decision, guidelines).
    d.  **Document:** `edit_file` to create/update `memory-bank/creative/creative-[component].md` using template from `Phases/CreativePhase/optimized-creative-template.mdc` (which you can `read_file`).
    e.  **Update `activeContext.md`:** `edit_file` to add summary to "Creative Decisions".
    f.  **Update `tasks.md`:** `edit_file` to mark creative sub-task complete.
3.  **Overall Verification & Transition:**
    a.  State: "CREATIVE mode complete. Designs documented."
    b.  Recommend: "Transition to IMPLEMENT mode." (Or VAN QA if applicable).

## ðŸ“Š PRE-CREATIVE CHECK (AI Self-Check)
1.  `tasks.md`: Planning complete for parent feature?
2.  `tasks.md`: Specific sub-tasks for "CREATIVE: Design..."?
(If fails, suggest PLAN mode.)
"""
        },
        # ... (Continue for implement-mode-map.mdc, plan-mode-map.mdc, qa-mode-map.mdc, reflect-mode-map.mdc) ...
        # ... (And then for all the van_mode_split files, ensuring they use fetch_rules to call each other) ...
        # Example for van-mode-map.mdc (the main orchestrator for VAN)
        {
            "path": ".cursor/rules/isolation_rules/visual-maps/van_mode_split/van-mode-map.mdc",
            "description": "Main orchestrator for VAN mode: platform detection, file verification, complexity determination, and optional QA. Fetched when VAN mode starts.",
            "globs": "**/visual-maps/van_mode_split/van-mode-map.mdc", # More specific glob
            "alwaysApply": False,
            "body": """
# VAN MODE: INITIALIZATION PROCESS MAP (AI Instructions)

> **TL;DR:** Initialize project: platform detection, file verification, complexity determination. For L2+ tasks, transition to PLAN. For L1, complete initialization. If 'VAN QA' is called, perform technical validation.

## ðŸ§­ VAN MODE PROCESS FLOW (AI Actions)

1.  **Acknowledge:**
    *   If user typed "VAN": Respond "OK VAN - Beginning Initialization Process."
    *   If user typed "VAN QA": Respond "OK VAN QA - Beginning Technical Validation." Proceed to step 6.
2.  **Platform Detection:**
    a.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/platform-awareness.mdc`.
    b.  Document detected platform in `memory-bank/activeContext.md` using `edit_file`.
3.  **File Verification & Creation (Memory Bank Setup):**
    a.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/file-verification.mdc`. This rule will guide you to check/create `memory-bank/` dir, subdirs, and core `.md` files using `edit_file` with initial templates.
4.  **Early Complexity Determination:**
    a.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/complexity-decision-tree.mdc`.
    b.  This rule will guide you to assess complexity (Level 1-4) and update `activeContext.md` and `tasks.md` using `edit_file`.
5.  **Mode Transition based on Complexity:**
    a.  If Level 1 determined:
        i.  State: "Level 1 task. Completing VAN initialization."
        ii. `edit_file` `memory-bank/activeContext.md` to note: "VAN Process Status: Level 1 Initialization Complete. Ready for IMPLEMENT mode."
        iii. State: "VAN Initialization Complete for Level 1 task. Recommend IMPLEMENT mode." Await user.
    b.  If Level 2-4 determined:
        i.  State: "ðŸš« LEVEL [2-4] TASK DETECTED. This task REQUIRES PLAN mode. You MUST switch to PLAN mode for proper documentation and planning."
        ii. State: "Type 'PLAN' to switch to planning mode." Await user.
        iii. (If user proceeds to PLAN, VAN is effectively paused until potentially VAN QA).
6.  **VAN QA - Technical Validation (if "VAN QA" was the entry or if called after CREATIVE):**
    a.  State: "Initiating VAN QA Technical Validation."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-qa-main.mdc`.
    c.  The `van-qa-main.mdc` will orchestrate fetching sub-rules for dependency, config, environment, and build tests.
    d.  Based on QA results (from `van-qa-main.mdc`'s execution):
        i.  If PASS: `fetch_rules` for `van-qa-utils/reports.mdc` to generate success report (using `edit_file` to output it). Then `fetch_rules` for `van-qa-utils/mode-transitions.mdc` to suggest BUILD mode.
        ii. If FAIL: `fetch_rules` for `van-qa-utils/reports.mdc` to generate failure report. Then `fetch_rules` for `van-qa-utils/common-fixes.mdc` to guide user. Await user to fix and re-type "VAN QA".

## ðŸ”„ QA COMMAND PRECEDENCE (If user types "QA" during VAN Initialization)
1.  Pause current VAN initialization step.
2.  State: "QA command received. Initiating VAN QA Technical Validation."
3.  Proceed to step 6 (VAN QA Technical Validation) above.
4.  After QA (pass/fail and potential fixes), if original VAN was for L1, resume L1 completion. If original VAN was for L2-4 and was about to transition to PLAN, re-confirm that transition.
"""
        },
        # Add ALL other visual-maps/*.mdc files here,
        # ensuring their textual instructions guide the AI to:
        # - Use `fetch_rules` to load sub-rules/detailed logic from Core/, LevelX/, Phases/, or other visual-maps/van_mode_split/ files.
        # - Use `edit_file` for all Memory Bank .md file updates.
        # - Use `read_file` for context.
        # - Use `run_terminal_cmd` for execution.
    ])

    if not MDC_FILES_DATA:
        print("No file data provided. Please populate the MDC_FILES_DATA list.")
    else:
        base_rules_path = ".cursor/rules/isolation_rules"
        if not os.path.exists(base_rules_path):
            os.makedirs(base_rules_path, exist_ok=True)
            print(f"Ensured base directory exists: {base_rules_path}")

        for file_data in MDC_FILES_DATA:
            create_or_update_mdc_file(
                file_data["path"],
                file_data["description"],
                file_data["globs"],
                file_data["alwaysApply"],
                file_data["body"]
            )
        print("\n--- MDC file generation process complete. ---")
        print("NOTE: This script overwrites existing files with the defined content.")