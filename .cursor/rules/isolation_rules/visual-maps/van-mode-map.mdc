---
description: Visual process map for VAN mode (Initialization)
globs: van-mode-map.mdc
alwaysApply: false
---
# VAN MODE: INITIALIZATION PROCESS MAP

> **TL;DR:** This document defines the VAN mode process for project initialization, task analysis, and technical validation. It guides users through platform detection, file verification, complexity determination, and technical validation to ensure proper setup before implementation.

## 🧭 VAN MODE PROCESS FLOW (AI Actions)

This flow describes the sequential steps you will take when operating in VAN Mode.

1.  **Acknowledge & Determine Entry Point:**
    *   If user typed "VAN": Respond "OK VAN - Beginning Initialization Process." Proceed with step 2.
    *   If user typed "VAN QA": Respond "OK VAN QA - Beginning Technical Validation." Skip to **Step 7 (VAN QA)**.

2.  **Initial Problem Intake & Quick Triage:**
    a.  State: "Performing initial problem intake and quick triage."
    b.  `read_file` the user's prompt and any immediately provided context files (like `error-delete-chat.txt`).
    c.  `read_file` the 1-2 most directly implicated source files if obvious from the error/request (e.g., `server.py` if an API error is mentioned).
    d.  **Decision Point - Quick Fix Assessment:**
        *   Based on this *very limited initial review*, can you confidently identify:
            1.  A highly localized problem (e.g., affects only one function or a few lines in one file)?
            2.  A clear root cause?
            3.  A simple, low-risk fix (e.g., correcting a variable name, adjusting a simple conditional, fixing a property access path like in the delete_chat example)?
            4.  The fix requires no new dependencies or significant design changes?
        *   **If YES to all above (High Confidence, Simple Fix):**
            i.  State: "Initial analysis suggests a straightforward Level 0/1 fix for [brief problem description]."
            ii. `edit_file memory-bank/tasks.md` to create a task: "L0/1 Quick Fix: [Problem Description]".
            iii. `edit_file memory-bank/activeContext.md` to log: "Focus: L0/1 Quick Fix - [Problem]. Initial diagnosis: [Root Cause]. Proposed fix: [Brief Fix]."
            iv. `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Level1/optimized-workflow-level1.mdc`.
                *   (This rule already guides: implement fix, verify, document concisely in `tasks.md`/`activeContext.md`, then state completion and readiness for a new task).
            v.  **After `Level1/optimized-workflow-level1.mdc` completes, the VAN mode for THIS SPECIFIC QUICK TASK is considered complete.** State this and await further user instruction (e.g., new VAN for another task, or switch to another mode).
            vi. **SKIP to Step 8 (QA Command Precedence Check & End of VAN for this task).**
        *   **If NO (Problem is not immediately obvious/simple, or any uncertainty):**
            i.  State: "Initial triage indicates further analysis is needed. Proceeding with standard VAN initialization."
            ii. Proceed to Step 3.

3.  **Platform Detection (Sub-Rule - Standard VAN Path):**
    a.  State: "Performing platform detection."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-platform-detection.mdc`.
    c.  (This fetched rule will guide OS detection and logging to `activeContext.md`).

4.  **File Verification & Creation (Memory Bank Setup) (Sub-Rule - Standard VAN Path):**
    a.  State: "Performing Memory Bank file verification and setup."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/file-verification.mdc`.
    c.  (This fetched rule guides creating/verifying `memory-bank/` structure and core files).

5.  **Full Context Analysis & Complexity Determination (Sub-Rule - Standard VAN Path):**
    a.  State: "Performing detailed context analysis and determining task complexity."
    b.  `read_file` relevant project files (README, main source files, etc.) as needed for a broader understanding.
    c.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/Core/complexity-decision-tree.mdc`.
    d.  (This fetched rule guides assessing Level 1-4 and updating `activeContext.md` and `tasks.md`).
    e.  `read_file memory-bank/activeContext.md` to confirm the determined complexity level.

6.  **Mode Transition based on Complexity (Standard VAN Path):**
    a.  **If Level 1 determined (and not handled by Quick Triage):**
        i.  State: "Task assessed as Level 1. Completing VAN initialization."
        ii. Use `edit_file` to update `memory-bank/activeContext.md` with: "VAN Process Status: Level 1 Initialization Complete. Task ready for IMPLEMENT mode."
        iii. State: "VAN Initialization Complete for Level 1 task [Task Name]. Recommend IMPLEMENT mode." Await user.
    b.  **If Level 2, 3, or 4 determined:**
        i.  State: "🚫 LEVEL [2/3/4] TASK DETECTED: [Task Name]. This task REQUIRES detailed planning."
        ii. State: "Transitioning to PLAN mode is necessary. Type 'PLAN' to proceed with planning." Await user.

7.  **VAN QA - Technical Validation (Entry point if "VAN QA" was typed, or if called after CREATIVE mode by user):**
    a.  State: "Initiating VAN QA Technical Validation."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/van_mode_split/van-qa-main.mdc`.
    c.  (This rule handles the QA process). Await user action based on QA report.

8.  **QA COMMAND PRECEDENCE (If user types "QA" during steps 3-6 of Standard VAN Initialization):**
    a.  State: "General QA command received, pausing current VAN initialization step ([current step])."
    b.  `fetch_rules` to load and follow `.cursor/rules/isolation_rules/visual-maps/qa-mode-map.mdc`.
    c.  After general QA is complete: State "Resuming VAN initialization." Continue from paused step.

## 🌐 PLATFORM DETECTION PROCESS

This section describes the platform detection process.

**Process Flow:**
1.  **Platform Detection.**
2.  **Detect Operating System:** Branches to Windows, macOS, or Linux detection.
3.  **Windows, macOS, or Linux -> Adapt Commands for Platform.**
4.  **Adapt Commands -> Path Separator Detection.**
    *   Windows Path: Backslash (`\`).
    *   macOS Path: Forward Slash (`/`).
    *   Linux Path: Forward Slash (`/`).
5.  **Path Separator Detection -> Command Checkpoint.**
    *   Windows Command Adaptations: `dir`, `icacls`, etc.
    *   macOS Command Adaptations: `ls`, `chmod`, etc.
    *   Linux Command Adaptations: `ls`, `chmod`, etc.
6.  **Path Separator Checkpoint & Command Checkpoint -> Platform Detection Complete.**

## 📁 FILE VERIFICATION PROCESS

This section describes the file verification process.

**Process Flow:**
1.  **File Verification.**
2.  **Check Essential Files.**
3.  **Check Memory Bank Structure.**
4.  **Memory Bank Exists?**
    *   If "Yes": Verify Memory Bank Contents.
    *   If "No": Create Memory Bank Structure.
5.  **Check Essential Files -> Check Documentation Files.**
6.  **Docs Exist?**
    *   If "Yes": Verify Documentation Structure.
    *   If "No": Create Documentation Structure.
7.  **Verify/Create Memory Bank & Verify/Create Docs -> Memory Bank Checkpoint & Documentation Checkpoint.**
8.  **Memory Bank Checkpoint & Documentation Checkpoint -> File Verification Complete.**

## 🧩 COMPLEXITY DETERMINATION PROCESS

This section describes the complexity determination process.

**Process Flow:**
1.  **Complexity Determination.**
2.  **Analyze Task Requirements.**
3.  **Analyze Task Requirements -> Check Task Keywords.**
4.  **Check Task Keywords -> Assess Scope Impact.**
5.  **Assess Scope Impact -> Evaluate Risk Level.**
6.  **Evaluate Risk Level -> Estimate Implementation Effort.**
7.  **Estimate Implementation Effort -> Determine Complexity Level.**
    *   If "Level 1": Level 1: Quick Bug Fix.
    *   If "Level 2": Level 2: Simple Enhancement.
    *   If "Level 3": Level 3: Intermediate Feature.
    *   If "Level 4": Level 4: Complex System.
8.  **Level 1 -> Complexity Determination Complete.**
9.  **Level 2, 3, or 4 -> Force Mode Switch to PLAN.**

## 🔄 COMPLETE WORKFLOW WITH QA VALIDATION

This section describes the complete workflow, including QA validation.

**Workflow Flow:**
*   VAN MODE (Initial Analysis) -> PLAN MODE (Task Planning) -> CREATIVE MODE (Design Decisions) -> VAN QA MODE (Technical Validation) -> BUILD MODE (Implementation).

## 🔍 TECHNICAL VALIDATION OVERVIEW

This section provides an overview of the four-point technical validation process.

**Validation Flow:**
1.  **VAN QA MODE.**
2.  **FOUR-POINT VALIDATION.**
3.  **1️⃣ DEPENDENCY VERIFICATION:** Check all required packages.
4.  **2️⃣ CONFIGURATION VALIDATION:** Verify format & compatibility.
5.  **3️⃣ ENVIRONMENT VALIDATION:** Check build environment.
6.  **4️⃣ MINIMAL BUILD TEST:** Test core functionality.
7.  **MINIMAL BUILD TEST -> All Checks Passed?**
    *   If "Yes": GENERATE SUCCESS REPORT -> Proceed to BUILD MODE.
    *   If "No": GENERATE FAILURE REPORT -> Fix Technical Issues -> Re-validate.

## 📝 VALIDATION STATUS FORMAT

```
╔═════════════════ 🔍 QA VALIDATION STATUS ═════════════════╗
│ ✓ Design Decisions   │ Verified as implementable          │
│ ✓ Dependencies       │ All required packages installed    │
│ ✓ Configurations     │ Format verified for platform       │
│ ✓ Environment        │ Suitable for implementation        │
╚════════════════════════════════════════════════════════════╝
✅ VERIFIED - Clear to proceed to BUILD mode
```

## 🚨 MODE TRANSITION TRIGGERS

### VAN to PLAN Transition
For complexity levels 2-4:
```
🚫 LEVEL [2-4] TASK DETECTED
Implementation in VAN mode is BLOCKED
This task REQUIRES PLAN mode
You MUST switch to PLAN mode for proper documentation and planning
Type 'PLAN' to switch to planning mode
```

### CREATIVE to VAN QA Transition
After completing the CREATIVE mode:
```
⏭️ NEXT MODE: VAN QA
To validate technical requirements before implementation, please type 'VAN QA'
```

### VAN QA to BUILD Transition
After successful validation:
```
✅ TECHNICAL VALIDATION COMPLETE
All prerequisites verified successfully
You may now proceed to BUILD mode
Type 'BUILD' to begin implementation
```

## 🔒 BUILD MODE PREVENTION MECHANISM

This section describes how the system prevents moving to BUILD mode without passing QA validation.

**Process Flow:**
1.  **Start: User Types: BUILD.**
2.  **QA Validation Completed?**
    *   If "Yes and Passed": Allow BUILD Mode.
    *   If "No or Failed": BLOCK BUILD MODE.
3.  **BLOCK BUILD MODE -> Display: ⚠️ QA VALIDATION REQUIRED.**
4.  **Display -> Prompt: Type VAN QA.**

## 🔄 QA COMMAND PRECEDENCE

QA validation can be called at any point in the process flow, and takes immediate precedence over any other current steps, including forced mode switches.

**Process Flow:**
1.  **User Types: QA.**
2.  **⚠️ HIGH PRIORITY COMMAND.**
3.  **Pause Current Task/Process.**
4.  **Load QA Mode Map.**
5.  **Execute QA Validation Process.**
6.  **QA Results.**
    *   If "PASS": Resume Prior Process Flow.
    *   If "FAIL": Fix Identified Issues -> Re-run QA Validation.

### QA Interruption Rules

When a user types **QA** at any point:

1. **The QA command MUST take immediate precedence** over any current operation, including the "FORCE MODE SWITCH" triggered by complexity assessment.
2. The system MUST:
   - Immediately load the QA mode map
   - Execute the full QA validation process
   - Address any failures before continuing
3. **Required remediation steps take priority** over any pending mode switches or complexity rules
4. After QA validation is complete and passes:
   - Resume the previously determined process flow
   - Continue with any required mode switches

```
⚠️ QA OVERRIDE ACTIVATED
All other processes paused
QA validation checks now running...
Any issues found MUST be remediated before continuing with normal process flow
```

## 📋 CHECKPOINT VERIFICATION TEMPLATE

Each major checkpoint in VAN mode uses this format:

```
✓ SECTION CHECKPOINT: [SECTION NAME]
- Requirement 1? [YES/NO]
- Requirement 2? [YES/NO]
- Requirement 3? [YES/NO]

→ If all YES: Ready for next section
→ If any NO: Fix missing items before proceeding
```

## 🚀 VAN MODE ACTIVATION

When the user types "VAN", respond with a confirmation and start the process:

```
User: VAN

Response: OK VAN - Beginning Initialization Process
```

After completing CREATIVE mode, when the user types "VAN QA", respond:

```
User: VAN QA

Response: OK VAN QA - Beginning Technical Validation
```

This ensures clear communication about which phase of VAN mode is active. 

## 🔍 DETAILED QA VALIDATION PROCESS

### 1️⃣ DEPENDENCY VERIFICATION

This step verifies that all required packages are installed and compatible.

**Process Flow:**
1.  **Start: Dependency Verification.**
2.  **Read Required Dependencies:** From Creative Phase.
3.  **Check if Dependencies are Installed.**
4.  **All Dependencies Installed?**
    *   If "Yes": Verify Versions and Compatibility.
    *   If "No": Install Missing Dependencies -> Verify Versions.
5.  **Versions Compatible?**
    *   If "Yes": Dependencies Verified ✅ PASS.
    *   If "No": Upgrade/Downgrade as Needed -> Retry Verification.

#### Windows (PowerShell) Implementation:
```powershell
# Example: Verify Node.js dependencies for a React project
function Verify-Dependencies {
    $requiredDeps = @{
        "node" = ">=14.0.0"
        "npm" = ">=6.0.0"
    }
    
    $missingDeps = @()
    $incompatibleDeps = @()
    
    # Check Node.js version
    $nodeVersion = $null
    try {
        $nodeVersion = node -v
        if ($nodeVersion -match "v(\d+)\.(\d+)\.(\d+)") {
            $major = [int]$Matches[1]
            if ($major -lt 14) {
                $incompatibleDeps += "node (found $nodeVersion, required >=14.0.0)"
            }
        }
    } catch {
        $missingDeps += "node"
    }
    
    # Check npm version
    $npmVersion = $null
    try {
        $npmVersion = npm -v
        if ($npmVersion -match "(\d+)\.(\d+)\.(\d+)") {
            $major = [int]$Matches[1]
            if ($major -lt 6) {
                $incompatibleDeps += "npm (found $npmVersion, required >=6.0.0)"
            }
        }
    } catch {
        $missingDeps += "npm"
    }
    
    # Display results
    if ($missingDeps.Count -eq 0 -and $incompatibleDeps.Count -eq 0) {
        Write-Output "✅ All dependencies verified and compatible"
        return $true
    } else {
        if ($missingDeps.Count -gt 0) {
            Write-Output "❌ Missing dependencies: $($missingDeps -join ', ')"
        }
        if ($incompatibleDeps.Count -gt 0) {
            Write-Output "❌ Incompatible versions: $($incompatibleDeps -join ', ')"
        }
        return $false
    }
}
```

#### Mac/Linux (Bash) Implementation:
```bash
#!/bin/bash

# Example: Verify Node.js dependencies for a React project
verify_dependencies() {
    local missing_deps=()
    local incompatible_deps=()
    
    # Check Node.js version
    if command -v node &> /dev/null; then
        local node_version=$(node -v)
        if [[ $node_version =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            local major=${BASH_REMATCH[1]}
            if (( major < 14 )); then
                incompatible_deps+=("node (found $node_version, required >=14.0.0)")
            fi
        fi
    else
        missing_deps+=("node")
    fi
    
    # Check npm version
    if command -v npm &> /dev/null; then
        local npm_version=$(npm -v)
        if [[ $npm_version =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            local major=${BASH_REMATCH[1]}
            if (( major < 6 )); then
                incompatible_deps+=("npm (found $npm_version, required >=6.0.0)")
            fi
        fi
    else
        missing_deps+=("npm")
    fi
    
    # Display results
    if [ ${#missing_deps[@]} -eq 0 ] && [ ${#incompatible_deps[@]} -eq 0 ]; then
        echo "✅ All dependencies verified and compatible"
        return 0
    else
        if [ ${#missing_deps[@]} -gt 0 ]; then
            echo "❌ Missing dependencies: ${missing_deps[*]}"
        fi
        if [ ${#incompatible_deps[@]} -gt 0 ]; then
            echo "❌ Incompatible versions: ${incompatible_deps[*]}"
        fi
        return 1
    fi
}
```

### 2️⃣ CONFIGURATION VALIDATION

This step validates configuration files format and compatibility.

**Process Flow:**
1.  **Start: Configuration Validation.**
2.  **Identify Configuration Files.**
3.  **Read Configuration Files.**
4.  **Validate Syntax and Format.**
5.  **Syntax Valid?**
    *   If "Yes": Check Compatibility with Platform.
    *   If "No": Fix Syntax Errors -> Retry Validation.
6.  **Compatible with Platform?**
    *   If "Yes": Configurations Validated ✅ PASS.
    *   If "No": Adapt Configurations for Platform -> Retry Compatibility Check.

#### Configuration Validation Implementation:
```powershell
# Example: Validate configuration files for a web project
function Validate-Configurations {
    $configFiles = @(
        "package.json",
        "tsconfig.json",
        "vite.config.js"
    )
    
    $invalidConfigs = @()
    $incompatibleConfigs = @()
    
    foreach ($configFile in $configFiles) {
        if (Test-Path $configFile) {
            # Check JSON syntax for JSON files
            if ($configFile -match "\.json$") {
                try {
                    Get-Content $configFile -Raw | ConvertFrom-Json | Out-Null
                } catch {
                    $invalidConfigs += "$configFile (JSON syntax error: $($_.Exception.Message))"
                    continue
                }
            }
            
            # Specific configuration compatibility checks
            if ($configFile -eq "vite.config.js") {
                $content = Get-Content $configFile -Raw
                # Check for React plugin in Vite config
                if ($content -notmatch "react\(\)") {
                    $incompatibleConfigs += "$configFile (Missing React plugin for React project)"
                }
            }
        } else {
            $invalidConfigs += "$configFile (file not found)"
        }
    }
    
    # Display results
    if ($invalidConfigs.Count -eq 0 -and $incompatibleConfigs.Count -eq 0) {
        Write-Output "✅ All configurations validated and compatible"
        return $true
    } else {
        if ($invalidConfigs.Count -gt 0) {
            Write-Output "❌ Invalid configurations: $($invalidConfigs -join ', ')"
        }
        if ($incompatibleConfigs.Count -gt 0) {
            Write-Output "❌ Incompatible configurations: $($incompatibleConfigs -join ', ')"
        }
        return $false
    }
}
```

### 3️⃣ ENVIRONMENT VALIDATION

This step checks if the environment is properly set up for the implementation.

**Process Flow:**
1.  **Start: Environment Validation.**
2.  **Check Build Environment.**
3.  **Verify Build Tools.**
4.  **Build Tools Available?**
    *   If "Yes": Check Permissions and Access.
    *   If "No": Install Required Build Tools -> Retry Verification.
5.  **Permissions Sufficient?**
    *   If "Yes": Environment Validated ✅ PASS.
    *   If "No": Fix Permission Issues -> Retry Permission Check.

#### Environment Validation Implementation:
```powershell
# Example: Validate environment for a web project
function Validate-Environment {
    $requiredTools = @(
        @{Name = "git"; Command = "git --version"},
        @{Name = "node"; Command = "node --version"},
        @{Name = "npm"; Command = "npm --version"}
    )
    
    $missingTools = @()
    $permissionIssues = @()
    
    # Check build tools
    foreach ($tool in $requiredTools) {
        try {
            Invoke-Expression $tool.Command | Out-Null
        } catch {
            $missingTools += $tool.Name
        }
    }
    
    # Check write permissions in project directory
    try {
        $testFile = ".__permission_test"
        New-Item -Path $testFile -ItemType File -Force | Out-Null
        Remove-Item -Path $testFile -Force
    } catch {
        $permissionIssues += "Current directory (write permission denied)"
    }
    
    # Check if port 3000 is available (commonly used for dev servers)
    try {
        $listener = New-Object System.Net.Sockets.TcpListener([System.Net.IPAddress]::Loopback, 3000)
        $listener.Start()
        $listener.Stop()
    } catch {
        $permissionIssues += "Port 3000 (already in use or access denied)"
    }
    
    # Display results
    if ($missingTools.Count -eq 0 -and $permissionIssues.Count -eq 0) {
        Write-Output "✅ Environment validated successfully"
        return $true
    } else {
        if ($missingTools.Count -gt 0) {
            Write-Output "❌ Missing tools: $($missingTools -join ', ')"
        }
        if ($permissionIssues.Count -gt 0) {
            Write-Output "❌ Permission issues: $($permissionIssues -join ', ')"
        }
        return $false
    }
}
```

### 4️⃣ MINIMAL BUILD TEST

This step performs a minimal build test to ensure core functionality.

**Process Flow:**
1.  **Start: Minimal Build Test.**
2.  **Create Minimal Test Project.**
3.  **Attempt Build.**
4.  **Build Successful?**
    *   If "Yes": Run Basic Functionality Test.
    *   If "No": Fix Build Issues -> Retry Build.
5.  **Test Passed?**
    *   If "Yes": Minimal Build Test ✅ PASS.
    *   If "No": Fix Test Issues -> Retry Test.

#### Minimal Build Test Implementation:
```powershell
# Example: Perform minimal build test for a React project
function Perform-MinimalBuildTest {
    $buildSuccess = $false
    $testSuccess = $false
    
    # Create minimal test project
    $testDir = ".__build_test"
    if (Test-Path $testDir) {
        Remove-Item -Path $testDir -Recurse -Force
    }
    
    try {
        # Create minimal test directory
        New-Item -Path $testDir -ItemType Directory | Out-Null
        Push-Location $testDir
        
        # Initialize minimal package.json
        @"
{
  "name": "build-test",
  "version": "1.0.0",
  "description": "Minimal build test",
  "main": "index.js",
  "scripts": {
    "build": "echo Build test successful"
  }
}
"@ | Set-Content -Path "package.json"
        
        # Attempt build
        npm run build | Out-Null
        $buildSuccess = $true
        
        # Create minimal test file
        @"
console.log('Test successful');
"@ | Set-Content -Path "index.js"
        
        # Run basic test
        node index.js | Out-Null
        $testSuccess = $true
        
    } catch {
        Write-Output "❌ Build test failed: $($_.Exception.Message)"
    } finally {
        Pop-Location
        if (Test-Path $testDir) {
            Remove-Item -Path $testDir -Recurse -Force
        }
    }
    
    # Display results
    if ($buildSuccess -and $testSuccess) {
        Write-Output "✅ Minimal build test passed successfully"
        return $true
    } else {
        if (-not $buildSuccess) {
            Write-Output "❌ Build process failed"
        }
        if (-not $testSuccess) {
            Write-Output "❌ Basic functionality test failed"
        }
        return $false
    }
}
```

## 📋 COMPREHENSIVE QA REPORT FORMAT

After running all validation steps, a comprehensive report is generated:

```
╔═════════════════════ 🔍 QA VALIDATION REPORT ══════════════════════╗
│                                                                     │
│  PROJECT: [Project Name]                                            │
│  TIMESTAMP: [Current Date/Time]                                     │
│                                                                     │
│  1️⃣ DEPENDENCY VERIFICATION                                         │
│  ✓ Required: [List of required dependencies]                        │
│  ✓ Installed: [List of installed dependencies]                      │
│  ✓ Compatible: [Yes/No]                                            │
│                                                                     │
│  2️⃣ CONFIGURATION VALIDATION                                        │
│  ✓ Config Files: [List of configuration files]                      │
│  ✓ Syntax Valid: [Yes/No]                                          │
│  ✓ Platform Compatible: [Yes/No]                                   │
│                                                                     │
│  3️⃣ ENVIRONMENT VALIDATION                                          │
│  ✓ Build Tools: [Available/Missing]                                │
│  ✓ Permissions: [Sufficient/Insufficient]                          │
│  ✓ Environment Ready: [Yes/No]                                     │
│                                                                     │
│  4️⃣ MINIMAL BUILD TEST                                              │
│  ✓ Build Process: [Successful/Failed]                              │
│  ✓ Functionality Test: [Passed/Failed]                             │
│  ✓ Build Ready: [Yes/No]                                           │
│                                                                     │
│  🚨 FINAL VERDICT: [PASS/FAIL]                                      │
│  ➡️ [Success message or error details]                              │
╚═════════════════════════════════════════════════════════════════════╝
```

## ❌ FAILURE REPORT FORMAT

If any validation step fails, a detailed failure report is generated:

```
⚠️⚠️⚠️ QA VALIDATION FAILED ⚠️⚠️⚠️

The following issues must be resolved before proceeding to BUILD mode:

1️⃣ DEPENDENCY ISSUES:
- [Detailed description of dependency issues]
- [Recommended fix]

2️⃣ CONFIGURATION ISSUES:
- [Detailed description of configuration issues]
- [Recommended fix]

3️⃣ ENVIRONMENT ISSUES:
- [Detailed description of environment issues]
- [Recommended fix]

4️⃣ BUILD TEST ISSUES:
- [Detailed description of build test issues]
- [Recommended fix]

⚠️ BUILD MODE IS BLOCKED until these issues are resolved.
Type 'VAN QA' after fixing the issues to re-validate.
```

## 🔄 INTEGRATION WITH DESIGN DECISIONS

The VAN QA mode reads and validates design decisions from the CREATIVE phase.

**Process Flow:**
1.  **Start: Read Design Decisions.**
2.  **Parse Creative Phase Documentation.**
3.  **Extract Technology Choices.**
4.  **Extract Required Dependencies.**
5.  **Build Validation Plan.**
6.  **Start Four-Point Validation Process.**

### Technology Extraction Process:
```powershell
# Example: Extract technology choices from creative phase documentation
function Extract-TechnologyChoices {
    $techChoices = @{}
    
    # Read from systemPatterns.md
    if (Test-Path "memory-bank\systemPatterns.md") {
        $content = Get-Content "memory-bank\systemPatterns.md" -Raw
        
        # Extract framework choice
        if ($content -match "Framework:\s*(\w+)") {
            $techChoices["framework"] = $Matches[1]
        }
        
        # Extract UI library choice
        if ($content -match "UI Library:\s*(\w+)") {
            $techChoices["ui_library"] = $Matches[1]
        }
        
        # Extract state management choice
        if ($content -match "State Management:\s*([^\n]+)") {
            $techChoices["state_management"] = $Matches[1].Trim()
        }
    }
    
    return $techChoices
}
```

## 🚨 IMPLEMENTATION PREVENTION MECHANISM

If QA validation fails, the system prevents moving to BUILD mode.

```powershell
# Example: Enforce QA validation before allowing BUILD mode
function Check-QAValidationStatus {
    $qaStatusFile = "memory-bank\.qa_validation_status"
    
    if (Test-Path $qaStatusFile) {
        $status = Get-Content $qaStatusFile -Raw
        if ($status -match "PASS") {
            return $true
        }
    }
    
    # Display block message
    Write-Output "`n`n"
    Write-Output "🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫"
    Write-Output "⛔️ BUILD MODE BLOCKED: QA VALIDATION REQUIRED"
    Write-Output "⛔️ You must complete QA validation before proceeding to BUILD mode"
    Write-Output "`n"
    Write-Output "Type 'VAN QA' to perform technical validation"
    Write-Output "`n"
    Write-Output "🚫 NO IMPLEMENTATION CAN PROCEED WITHOUT VALIDATION 🚫"
    Write-Output "🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫"
    
    return $false
}
```

## 🧪 COMMON QA VALIDATION FIXES

Here are common fixes for issues encountered during QA validation:

### Dependency Issues:
- **Missing Node.js**: Install Node.js from https://nodejs.org/
- **Outdated npm**: Run `npm install -g npm@latest` to update
- **Missing packages**: Run `npm install` or `npm install [package-name]`

### Configuration Issues:
- **Invalid JSON**: Use a JSON validator to check syntax
- **Missing React plugin**: Add `import react from '@vitejs/plugin-react'` and `plugins: [react()]` to vite.config.js
- **Incompatible TypeScript config**: Update `tsconfig.json` with correct React settings

### Environment Issues:
- **Permission denied**: Run terminal as administrator (Windows) or use sudo (Mac/Linux)
- **Port already in use**: Kill process using the port or change the port in configuration
- **Missing build tools**: Install required command-line tools

### Build Test Issues:
- **Build fails**: Check console for specific error messages
- **Test fails**: Verify minimal configuration is correct
- **Path issues**: Ensure paths use correct separators for the platform

## 🔒 FINAL QA VALIDATION CHECKPOINT

```
✓ SECTION CHECKPOINT: QA VALIDATION
- Dependency Verification Passed? [YES/NO]
- Configuration Validation Passed? [YES/NO]
- Environment Validation Passed? [YES/NO]
- Minimal Build Test Passed? [YES/NO]

→ If all YES: Ready for BUILD mode
→ If any NO: Fix identified issues before proceeding
```
